


















Support for domain creation of different types (0416704b) · Commits · mars-research / Redleaf / redleaf · GitLab













































Skip to content




GitLab














Projects
Groups
Snippets

Help
















Loading...

























Help







Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation











R


redleaf







Project overview



Project overview



Details


Activity


Releases







Repository



Repository



Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues


21



Issues


21



List


Boards


Labels


Service Desk


Milestones







Merge requests


0



Merge requests


0






CI/CD



CI/CD



Pipelines


Jobs


Schedules







Operations



Operations



Incidents


Environments







Packages & Registries



Packages & Registries



Package Registry


Container Registry







Analytics



Analytics



CI/CD


Repository


Value Stream







Wiki



Wiki






Snippets



Snippets






Members



Members




Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards





Collapse sidebar


Close sidebar








Open sidebar



mars-researchRedleaf redleaf
Commits


0416704b
















Commit
0416704b


authored
Dec 26, 2019
by


Anton Burtsev



Browse files




Support for domain creation of different types







parent
4b2f3df8














Changes
5




Hide whitespace changes

Inline
Side-by-side



Showing
5 changed files

with
204 additions
and
36 deletions


+204
-36










Makefile

Makefile


+4
-1








src/domain/create_domain.rs

src/domain/create_domain.rs


+187
-20








src/domain/mod.rs

src/domain/mod.rs


+1
-1








src/lib.rs

src/lib.rs


+1
-14








sys/interfaces/syscalls/src/lib.rs

sys/interfaces/syscalls/src/lib.rs


+11
-0





No files found.


















Makefile







View file @ 0416704b






......@@ -14,7 +14,10 @@ xv6fs_img = usr/mkfs/build/fs.img









root := ./










domain_list := sys/init/build/init \










	usr/xv6/kernel/core/build/xv6kernel \










	usr/xv6/kernel/fs/build/xv6fs










	usr/xv6/kernel/fs/build/xv6fs \










	sys/dev/pci/build/pci \










	sys/dev/ahci/build/ahci \










	sys/dev/ixgbe/build/ixgbe





















qemu_common := -m 128m -vga std -s










qemu_common := $(qemu_common) -cdrom $(iso)



......














src/domain/create_domain.rs







View file @ 0416704b













use elfloader::ElfBinary;










use super::Domain;










use syscalls::{Syscall};










use syscalls::{Syscall, BDev, PCI, VFS};










use crate::syscalls::{PDomain};










use core::mem::transmute;










use crate::interrupt::{disable_irq, enable_irq};



......@@ -11,17 +11,192 @@ use alloc::boxed::Box;









//use crate::domain::domain::BOOTING_DOMAIN; 










//use crate::syscalls::BOOT_SYSCALL; 





















pub unsafe fn create_domain(name: &'static str, binary_range: (*const u8, *const u8)) {










 let (binary_start, binary_end) = binary_range;










 //type UserInit = fn(BootSyscall);





















pub fn create_domain_init() {










 extern "C" {










 fn _binary_sys_init_build_init_start();










 fn _binary_sys_init_build_init_end();










 }





















 let binary_range = (










 _binary_sys_init_build_init_start as *const u8,










 _binary_sys_init_build_init_end as *const u8










 );





















 unsafe {










 create_domain("sys_init", binary_range);










 }





















}





















pub fn create_domain_pci() -> Box<dyn PCI> {





















 extern "C" {










 fn _binary_sys_dev_pci_build_pci_start();










 fn _binary_sys_dev_pci_build_pci_end();










 }





















 let binary_range = (










 _binary_sys_dev_pci_build_pci_start as *const u8,










 _binary_sys_dev_pci_build_pci_end as *const u8










 );





















 let pci = unsafe {










 create_domain_pci_bus("pci", binary_range)










 };





















 return pci;










}





















pub fn create_domain_ahci(pci: Box<dyn PCI>) -> Box<dyn BDev> {





















 extern "C" {










 fn _binary_sys_dev_ahci_build_ahci_start();










 fn _binary_sys_dev_ahci_build_ahci_end();










 }





















 let binary_range = (










 _binary_sys_dev_ahci_build_ahci_start as *const u8,










 _binary_sys_dev_ahci_build_ahci_end as *const u8










 );





















 let bdev = unsafe {










 create_domain_bdev("ahci", binary_range, pci)










 };





















 return bdev;





















}





















pub fn create_domain_xv6kernel() {










 extern "C" {










 fn _binary_usr_xv6_kernel_core_build_xv6kernel_start();










 fn _binary_usr_xv6_kernel_core_build_xv6kernel_end();










 }





















 let binary_range = (










 _binary_usr_xv6_kernel_core_build_xv6kernel_start as *const u8,










 _binary_usr_xv6_kernel_core_build_xv6kernel_end as *const u8










 );





















 unsafe {










 create_domain("xv6kernel", binary_range);










 }





















}





















pub fn create_domain_xv6fs(bdev: Box<dyn BDev>) -> Box<dyn VFS> {





















 extern "C" {










 fn _binary_usr_xv6_kernel_core_build_xv6fs_start();










 fn _binary_usr_xv6_kernel_core_build_xv6fs_end();










 }





















 let binary_range = (










 _binary_usr_xv6_kernel_core_build_xv6fs_start as *const u8,










 _binary_usr_xv6_kernel_core_build_xv6fs_end as *const u8










 );





















 let vfs = unsafe {










 create_domain_fs("xv6fs", binary_range, bdev)










 };





















 return vfs;





















}





















pub unsafe fn create_domain_pci_bus(name: &str, 










 binary_range: (*const u8, *const u8)) -> Box<dyn PCI> 










{










 type UserInit = fn(Box<dyn Syscall>) -> Box<dyn PCI>;





















 let (dom, entry) = load_domain(name, binary_range);





















 let user_ep: UserInit = transmute::<*const(), UserInit>(entry);





















 let pdom = Box::new(PDomain::new(Arc::clone(&dom)));










 










 // Enable interrupts on exit to user so it can be preempted










 enable_irq();










 let pci = user_ep(pdom); 










 disable_irq(); 





















 println!("domain/{}: returned from entry point", name);










 return pci; 










}
































pub unsafe fn create_domain_bdev(name: &str, 










 binary_range: (*const u8, *const u8), 










 pci: Box<dyn PCI>) -> Box<dyn BDev> {










 type UserInit = fn(Box<dyn Syscall>, Box<dyn PCI>) -> Box<dyn BDev>;





















 let (dom, entry) = load_domain(name, binary_range);





















 let user_ep: UserInit = transmute::<*const(), UserInit>(entry);





















 let pdom = Box::new(PDomain::new(Arc::clone(&dom)));










 










 // Enable interrupts on exit to user so it can be preempted










 enable_irq();










 let bdev = user_ep(pdom, pci); 










 disable_irq(); 





















 println!("domain/{}: returned from entry point", name);










 return bdev; 










}





















pub unsafe fn create_domain_fs(name: &str, 










 binary_range: (*const u8, *const u8), 










 bdev: Box<dyn BDev>) -> Box<dyn VFS> 










{










 type UserInit = fn(Box<dyn Syscall>, Box<dyn BDev>) -> Box<dyn VFS>;










 










 let (dom, entry) = load_domain(name, binary_range);





















 let user_ep: UserInit = transmute::<*const(), UserInit>(entry);





















 let pdom = Box::new(PDomain::new(Arc::clone(&dom)));










 










 // Enable interrupts on exit to user so it can be preempted










 enable_irq();










 let vfs = user_ep(pdom, bdev); 










 disable_irq(); 





















 println!("domain/{}: returned from entry point", name);










 return vfs; 










}
































pub unsafe fn create_domain(name: &str, binary_range: (*const u8, *const u8)) {










 type UserInit = fn(Box<dyn Syscall>);





















 let (dom, entry) = load_domain(name, binary_range);





















 let user_ep: UserInit = transmute::<*const(), UserInit>(entry);





















 let pdom = Box::new(PDomain::new(Arc::clone(&dom)));










 










 // Enable interrupts on exit to user so it can be preempted










 enable_irq();










 user_ep(pdom); 










 disable_irq(); 





















 println!("domain/{}: returned from entry point", name);










}





















pub unsafe fn load_domain(name: &str, binary_range: (*const u8, *const u8)) -> (Arc<Mutex<Domain>>, *const()) {










 let (binary_start, binary_end) = binary_range;





















 let num_bytes = ((binary_end as usize) - (binary_start as usize)) as usize;





















 println!("domain/{}: Binary start: {:x}, end: {:x} ", name, binary_start as usize, binary_end as usize);










 println!("domain/{}: Binary start: {:x}, end: {:x} ", 










 name, binary_start as usize, binary_end as usize);





















 // Create a new elf binary from the address range we just extracted










 let domain_elf = ElfBinary::new(name, core::slice::from_raw_parts(binary_start, num_bytes)).expect("Invalid ELF file");










 let domain_elf = ElfBinary::new(name, 










 core::slice::from_raw_parts(binary_start, num_bytes))










 .expect("Invalid ELF file");





















 // Create a domain for the to-be-loaded elf file










 let dom = Arc::new(Mutex::new(Domain::new(name)));



......@@ -32,28 +207,20 @@ pub unsafe fn create_domain(name: &'static str, binary_range: (*const u8, *const









 domain_elf.load(&mut *loader).expect("Cannot load binary");





















 // print its entry point for now










 println!("domain/{}: Entry point at {:x}", name, loader.offset + domain_elf.entry_point());










 println!("domain/{}: Entry point at {:x}", 










 name, loader.offset + domain_elf.entry_point());





















 let user_ep: UserInit = {










 let user_ep: *const() = {










 let mut entry: *const u8 = (*loader).offset.as_ptr();










 entry = entry.offset(domain_elf.entry_point() as isize);










 let _entry = entry as *const ();










 transmute::<*const(), UserInit>(_entry)










 _entry










 };





















 // Drop the lock so if domain starts creating threads we don't










 // deadlock










 drop(loader);





















 let pdom = Box::new(PDomain::new(Arc::clone(&dom)));










 










 //BOOTING_DOMAIN.replace(Some(pdom));










 //user_ep(BOOT_SYSCALL);










 










 // Enable interrupts on exit to user so it can be preempted










 enable_irq();










 user_ep(pdom); 










 disable_irq(); 





















 println!("domain/{}: returned from entry point", name);










 return (dom, user_ep); 










}

























src/domain/mod.rs







View file @ 0416704b













pub mod domain;










pub use domain::Domain;





















mod create_domain;










pub mod create_domain;










pub use create_domain::create_domain;





















pub mod sys_init;



......














src/lib.rs







View file @ 0416704b






......@@ -54,7 +54,6 @@ use core::alloc::{Layout};









use crate::interrupt::{enable_irq};










use crate::memory::{construct_pt, construct_ap_pt};










use crate::pci::scan_pci_devs;










use crate::domain::create_domain;





















#[no_mangle]










pub static mut cpu1_stack: u32 = 0;



......@@ -122,19 +121,7 @@ fn test_threads() {































fn init_user() {










 extern "C" {










 fn _binary_sys_init_build_init_start();










 fn _binary_sys_init_build_init_end();










 }





















 let binary_range = (










 _binary_sys_init_build_init_start as *const u8,










 _binary_sys_init_build_init_end as *const u8










 );





















 unsafe {










 create_domain("sys_init", binary_range);










 }










 crate::domain::create_domain::create_domain_init(); 










}





















const MAX_CPUS: u32 = 32;



......














sys/interfaces/syscalls/src/lib.rs







View file @ 0416704b






......@@ -22,3 +22,14 @@ pub trait Syscall {









pub trait Thread {










 fn set_affinity(&self, affinity: u64);










}





















pub trait PCI {










}





















pub trait VFS {










}





















pub trait BDev {










}







































Write




Preview































Markdown
is
supported






0%










Try again


or


attach a new file


.




Attach a file




Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel




Please register or sign in to comment











